valgrind --leak-check=full --track-origins=yes --track-fds=yes ./cube3D ./assets/maps/bad/textures_duplicates.cub






VALIDE OU PAS ICI ?


subject.cub
        1111111111111111111111111
        1000000000110000000000001
        1011000001110000000000001
        1001000000000000000000001
111111111011000001110000000000001
100000000011000001110111111111111
11110111111111011100000010001
11110111111111011101010010001
11000000110101011100000010001
10000000000000001100000010001
10000000000000001101010010001
11000001110101011111011110N0111
11110111 1110101 101111010001
11111111 1111111 111111111111




forbidden.cub
111111111111
1         11         
1          1
111111111111
10S000000001
111111111111
11         1
111111111111








EUUUUHHH ???


test_map_hole.cub
111111111111
1         11
1       0001
1000000 0011
10S000000001
111111111111
11         1
111111111111





On est ok avec ca ?
test_map.cub

111111111111
1         11
1          1
111111111111
10S000000001
111111111111
11         1
111111111111




Pourquoi test_pos_bottom.cub ne marche pas aussi bien que le parisian studio ?

valgrind --leak-check=full --track-origins=yes --track-fds=yes ./cube3D ./assets/maps/test/parisian_studio.cub

valgrind --leak-check=full --track-origins=yes --track-fds=yes ./cube3D ./assets/maps/good/test_pos_bottom.cub



Alors que lui marche bien :
valgrind --leak-check=full --track-origins=yes --track-fds=yes ./cube3D ./assets/maps/good/test_pos_left.cub



le gnl a qui ?\
















// static void	ft_print_split(char **split)
// {
// 	int	i;

// 	i = 0;
// 	if (!split)
// 	{
// 		printf("split is NULL\n");
// 		return ;
// 	}
// 	while (split[i])
// 	{
// 		printf("[%s] | ", split[i]);
// 		i++;
// 	}
// 	if (split[i] == NULL)
// 		printf("[NULL]");
// 	printf("\n\n");
// }

// static void	ft_print_file_infos(t_env *env)
// {
// 	printf("NO = [%s]\n", env->img[NORTH].path);
// 	printf("SO = [%s]\n", env->img[SOUTH].path);
// 	printf("WE = [%s]\n", env->img[WEST].path);
// 	printf("EA = [%s]\n", env->img[EAST].path);
// 	printf("FLOOR = [%d, %d, %d]\n", env->file.colors[FLOOR][R], env->file.colors[FLOOR][G], env->file.colors[FLOOR][B]);
// 	printf("CEIL = [%d, %d, %d]\n", env->file.colors[CEIL][R], env->file.colors[CEIL][G], env->file.colors[CEIL][B]);
// }

// static void	ft_print_map(t_env *env)
// {
// 	char	**map;
// 	int		row;
// 	int		col;

// 	map = env->map;
// 	row = 0;
// 	while (row < env->maph)
// 	{
// 		col = 0;
// 		while (col < env->mapw)
// 		{
// 			// if ((int)(env->px) == col && (int)(env->py) == row)
// 			// 	printf("[P]");
// 			// else
// 				printf("[%c]", map[col][row]);
// 			col++;
// 		}
// 		printf("\n");
// 		row++;
// 	}
// }